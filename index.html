<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>River + Islands (3D)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #hud {
      position: absolute; left: 12px; top: 12px; right: 12px;
      color: rgba(255,255,255,.9); font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
      font-size: 14px; line-height: 1.2;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,.65);
    }
    #badge {
      padding: 8px 10px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
    }
    #hint {
      padding: 8px 10px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.18);
      border-radius: 10px;
      text-align: right;
    }
  </style>
</head>
<body>
<div id="hud">
  <div id="badge">River + Islands (3D)</div>
  <div id="hint">1 finger: rotate • 2 fingers: pan • pinch: zoom</div>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.set(0, 120, 160);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.screenSpacePanning = true;
  controls.minDistance = 30;
  controls.maxDistance = 450;
  controls.maxPolarAngle = Math.PI * 0.49; // keep above horizon
  controls.target.set(0, 0, 0);

  // Lights (soft, mobile-friendly)
  scene.add(new THREE.AmbientLight(0xffffff, 0.95));
  const dir = new THREE.DirectionalLight(0xffffff, 0.65);
  dir.position.set(120, 220, 80);
  scene.add(dir);

  // Load assets
  const texLoader = new THREE.TextureLoader();
  const texture = await texLoader.loadAsync('./texture.jpg');
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.anisotropy = 4;

  // Heightmap into canvas for sampling
  const heightImg = new Image();
  heightImg.src = './height.png';
  await heightImg.decode();

  const canvas = document.createElement('canvas');
  canvas.width = heightImg.width;
  canvas.height = heightImg.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(heightImg, 0, 0);
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

  function sampleHeight(u, v) {
    // u,v in [0,1], v flipped for canvas coords
    const x = Math.max(0, Math.min(canvas.width - 1, Math.floor(u * (canvas.width - 1))));
    const y = Math.max(0, Math.min(canvas.height - 1, Math.floor((1 - v) * (canvas.height - 1))));
    const idx = (y * canvas.width + x) * 4;
    return imgData[idx] / 255; // grayscale
  }

  // Geometry: plane with enough subdivisions for smooth islands
  const W = 220; // world width
  const H = W * (texture.image.height / texture.image.width);

  const segX = 240;
  const segY = Math.max(140, Math.floor(segX * (H / W)));

  const geom = new THREE.PlaneGeometry(W, H, segX, segY);
  geom.rotateX(-Math.PI / 2);

  // Displace vertices by heightmap
  const pos = geom.attributes.position;
  const uv = geom.attributes.uv;

  const maxLift = 14; // island height (visual)
  for (let i = 0; i < pos.count; i++) {
    const u = uv.getX(i);
    const v = uv.getY(i);
    const h = sampleHeight(u, v);
    // lift only land (water stays flat)
    pos.setY(i, h * maxLift);
  }
  pos.needsUpdate = true;
  geom.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({
    map: texture,
    roughness: 0.95,
    metalness: 0.0
  });

  const mesh = new THREE.Mesh(geom, mat);
  scene.add(mesh);

  // Subtle background
  scene.background = new THREE.Color(0x0b0f14);

  // Frame the map nicely
  controls.target.set(0, 0, 0);
  controls.update();

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
